#lec 3 SPOC Discussion

## 第三讲 启动、中断、异常和系统调用-思考题

## 3.1 BIOS
 1. 比较UEFI和BIOS的区别。

> UEFI的全称是统一的可扩展固件接口，与BIOS不同的是，BIOS是固化在主板上的程序，在BIOS下启动操作系统，必须从硬盘上指定扇区读取系统启动代码（包含在主引导记录中），然后从活动分区中引导启动操作系统，而UEFI已具备文件系统的支持，可以直接从文件系统中加载操作系统，省却中间步骤，并且UEFI拥有许多BIOS所不具备的功能，比如图形化界面、多种多样的操作方式、允许植入硬件驱动等等。

 1. 描述PXE的大致启动流程。

>	PXE是网络启动的一个标准。在启动过程中，终端要求服务器分配IP地址，再用TFTP或MTFTP协议下载一个启动软件包到本机内存中执行，由这个启动软件包完成终端基本软件设置，从而引导预先安装在服务器中的终端操作系统。

## 3.2 系统启动流程
 1. 了解NTLDR的启动流程。
 1. 了解GRUB的启动流程。
 1. 比较NTLDR和GRUB的功能有差异。
 1. 了解u-boot的功能。

## 3.3 中断、异常和系统调用比较
 1. 举例说明Linux中有哪些中断，哪些异常？

>	如外设输入输出的中断、设备故障的中断等。异常有除零异常，非法访问内存异常等。
 
 1. Linux的系统调用有哪些？大致的功能分类有哪些？  (w2l1)

>	Linux的系统调用数量有上百个，大致分为如下八类：进程控制（如：fork	创建一个新进程，clone	按指定条件创建子进程，execve	运行可执行文件，exit	中止进程等），文件系统控制（如：open	打开文件，chdir	改变当前工作目录，mkdir	创建目录，mknod	创建索引节点等），系统控制（如：ioctl	I/O总控制函数，_sysctl	读/写系统参数，acct	启用或禁止进程记账，getrlimit	获取系统资源上限），内存管理（如：brk	改变数据段空间的分配，sbrk	参见brk，mlock	内存页面加锁，munlock	内存页面解锁等），网络管理（如：getdomainname	取域名，setdomainname	设置域名，gethostid	获取主机标识号，sethostid	设置主机标识号等），socket控制，用户管理，进程间通信。

```
  + 采分点：说明了Linux的大致数量（上百个），说明了Linux系统调用的主要分类（文件操作，进程管理，内存管理等）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 
 1. 以ucore lab8的answer为例，uCore的系统调用有哪些？大致的功能分类有哪些？(w2l1)

>	uCore的系统调用大约有22个，大致分为如下三类：
>	
>	进程控制（如：sys_exit 中止进程，sys_fork 创建一个新进程，sys_wait 等待子进程终止，sys_exec 运行可执行文件，sys_yield 进程主动让出处理器,并将自己等候调度队列队尾，sys_getpid 获取进程标识号，sys_lab6_set_priority 设置进程优先级，sys_sleep 使进程睡眠，sys_kill 结束进程），
>	
>	文件系统控制（如：sys_open 打开文件，sys_close 关闭文件描述字，sys_read 读文件，sys_write 写文件，sys_seek 移动文件指针，sys_fstat 获取文件状态信息，sys_fsync 把文件在内存中的部分写回磁盘，sys_getcwd 获取当前工作目录，sys_getdirentry 读取目录项，sys_dup 复制已打开的文件描述字，sys_pgdir），
>	
>	系统控制（如：sys_gettime，获取系统时间，sys_putc 输出字符）

 ```
  + 采分点：说明了ucore的大致数量（二十几个），说明了ucore系统调用的主要分类（文件操作，进程管理，内存管理等）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 
## 3.4 linux系统调用分析
 1. 通过分析[lab1_ex0](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex0.md)了解Linux应用的系统调用编写和含义。(w2l1)

>	objdump工具用来显示文件信息，提供了诸多功能，如-d 反汇编，-f 显示头部摘要信息等。
>	
>	file工具用来通过查看文件的头部信息来获取文件类型，也可用来辨别一些文件的编码格式。
>	
>	nm工具用来列出目标文件的符号清单，对于每一个符号，nm列出其值(the symbol value)，类型（the symbol type）和其名字(the symbol name)，符号类型说明如下:
>	>	A
>	>	
>	>	该符号的值是绝对的，在以后的链接过程中，不允许进行改变。这样的符号值，常常出现在中断向量表中，例如用符号来表示各个中断向量函数在中断向量表中的位置。
>	>	
>	>	B
>	>	
>	>	该符号的值出现在非初始化数据段(bss)中。例如，在一个文件中定义全局static int test。则该符号test的类型为b，位于bss section中。其值表示该符号在bss段中的偏移。一般而言，bss段分配于RAM中
>	>	
>	>	C
>	>	
>	>	该符号为common。common symbol是未初始话数据段。该符号没有包含于一个普通section中。只有在链接过程中才进行分配。符号的值表示该符号需要的字节数。例如在一个c文件中，定义int test，并且该符号在别的地方会被引用，则该符号类型即为C。否则其类型为B。
>	>	
>	>	D
>	>	
>	>	该符号位于初始话数据段中。一般来说，分配到data section中。例如定义全局int baud_table[5] = {9600, 19200, 38400, 57600, 115200}，则会分配于初始化数据段中。
>	>	
>	>	G
>	>	
>	>	该符号也位于初始化数据段中。主要用于small object提高访问small data object的一种方式。
>	>	
>	>	I
>	>	
>	>	该符号是对另一个符号的间接引用。
>	>	
>	>	N
>	>	
>	>	该符号是一个debugging符号。
>	>	
>	>	R
>	>	
>	>	该符号位于只读数据区。例如定义全局const int test[] = {123, 123};则test就是一个只读数据区的符号。注意在cygwin下如果使用gcc直接编译成MZ格式时，源文件中的test对应_test，并且其符号类型为D，即初始化数据段中。但是如果使用m6812-elf-gcc这样的交叉编译工具，源文件中的test对应目标文件的test,即没有添加下划线，并且其符号类型为R。一般而言，位于rodata section。值得注意的是，如果在一个函数中定义const char *test = “abc”, const char test_int = 3。使用nm都不会得到符号信息，但是字符串“abc”分配于只读存储器中，test在rodata section中，大小为4。
>	>	
>	>	S
>	>	
>	>	符号位于非初始化数据区，用于small object。
>	>	
>	>	T
>	>	
>	>	该符号位于代码区text section。
>	>	
>	>	U
>	>	
>	>	该符号在当前文件中是未定义的，即该符号的定义在别的文件中。例如，当前文件调用另一个文件中定义的函数，在这个被调用的函数在当前就是未定义的；但是在定义它的文件中类型是T。但是对于全局变量来说，在定义它的文件中，其符号类型为C，在使用它的文件中，其类型为U。
>	>	
>	>	V
>	>	
>	>	该符号是一个weak object。
>	>	
>	>	W
>	>	
>	>	The symbol is a weak symbol that has not been specifically tagged as a weak object symbol
>	>	
>	>	\-
>	>	
>	>	该符号是a.out格式文件中的stabs symbol。
>	>	
>	>	?
>	>	
>	>	该符号类型没有定义
>	
>	Linux的每个系统调用都有一个定义好的数字，这些数字是用来构造这些系统调用的。内核通过0x80中断来管理这些系统调用。这些系统调用的对应的数字和一些参数都在调用的时候送到某些寄存器里面。系统调用的数字实际上是一个序列号，表示其在系统的一个数组sys_call_table[]中的位置。

 ```
  + 采分点：说明了objdump，nm，file的大致用途，说明了系统调用的具体含义
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分） 
 ```
 
 1. 通过调试[lab1_ex1](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex1.md)了解Linux应用的系统调用执行过程。(w2l1)

>	strace常用来跟踪进程执行时的系统调用和所接收的信号。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。
>	
>	 以x86系统为例，系统调用的具体执行过程为：在触发软中断前把调用号装入eax寄存器，之后通过int$0x80指令产生软中断，这条指令会触发一个异常导致系统切换到内核态并执行第128号异常处理程序，而该程序正是系统调用处理程序，名字叫system_call()，system_call()通过将给定的系统调用号与NR_syscalls做比较来检查其有效性。如果它大于或者等于NR_syscalls，该函数就返回-ENOSYS，否则，就执行相应的系统调用：call *sys_call_table(, %eax, 4);
>	 
>	 除了系统调用号以外，还需要一些外部的参数输入。最简单的办法就是像传递系统调用号一样把这些参数也存放在寄存器里。在x86系统上ebx,ecx,edx,esi和edi按照顺序存放前5个参数。需要六个或六个以上参数的情况不多见，此时，应该用一个单独的寄存器存放指向所有这些参数在用户空间地址的指针。给用户空间的返回值也通过寄存器传递。在x86系统上，它存放在eax寄存器中。

 ```
  + 采分点：说明了strace的大致用途，说明了系统调用的具体执行过程（包括应用，CPU硬件，操作系统的执行过程）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 
## 3.5 ucore系统调用分析
 1. ucore的系统调用中参数传递代码分析。
 1. ucore的系统调用中返回结果的传递代码分析。
 1. 以ucore lab8的answer为例，分析ucore 应用的系统调用编写和含义。
 1. 以ucore lab8的answer为例，尝试修改并运行代码，分析ucore应用的系统调用执行过程。
 
## 3.6 请分析函数调用和系统调用的区别
 1. 请从代码编写和执行过程来说明。
   1. 说明`int`、`iret`、`call`和`ret`的指令准确功能
 
